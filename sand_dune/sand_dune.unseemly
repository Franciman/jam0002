import /[build_a_language.unseemly]/
extend_syntax
    # Reserve some words:
    DefaultAtom ::= common ( ,{DefaultWord}, reserving 'Atoms' 'Rules' 'Start' 'No' ) ;

    # Reserve some symbols:
    DefaultToken ::= /\s*(\[|\]|\||->|capture_language|_)/ ;

    Expr ::= alt[
        # `ActuallyBool` is a hack; we need type variable inside each `*`
        forall ActuallyBool . '{[
            lit ,{DefaultWord}, = 'Atoms'
            # [
                atom_name := ( ,{Pat<Bool>}, )
                ,{DefaultSeparator},
                spelling := ( /'(.)'/ )  # any single character in quotes
            # ] *
            lit ,{DefaultWord}, = 'Rules'
            [
                ,{DefaultSeparator},
                lit ,{DefaultToken}, = '['
                [
                    lhs := ( ,{Expr< [ActuallyBool -> **[Bool Bool]** ] >}, ) # <-- atom_name : Bool
                    alt[ lit ,{DefaultToken}, = ']'  lit ,{DefaultToken}, = '|' ]alt
                ] *
                lit ,{DefaultToken}, = '->'
                lit ,{DefaultToken}, = '['
                [
                    rhs := ( ,{Expr< [ActuallyBool -> **[Bool Bool]** ] >}, ) # <-- atom_name : Bool
                    alt[ lit ,{DefaultToken}, = ']'  lit ,{DefaultToken}, = '|' ]alt
                ] *
            ] *
            lit ,{DefaultWord}, = 'Start'
            ,{DefaultSeparator},
            start_pattern := ( /\[([^\]]*)\]/ )
        ]}' top_level -> .{
            '[Expr|
                let string_pattern = ,[(prefab (string_to_sequence (ident_to_string start_pattern)))], ; in
                    # Inconveniently, `cell` is also Unseemly's word for a mutable container.
                let pattern = (map string_pattern .[ char : Int . (new_cell (equal? char 35)) ].) ;
                    # Buffer all writes so that subsequent rules don't "see" each other's effects.
                    # (This is different than how PuzzleScript does it, but it allows cellular-automaton-like behavior)
                    pattern_buffer = (map string_pattern .[ char : Int . (new_cell (equal? char 35)) ].) ;
                    output = (new_cell "
") ; in


                -{
                    for step in (range 0 25) -{
                        # output:
                        for entry in pattern
                            (assign output (concat (value output)
                                (if (value entry) "#" " "))) ;
                        # append a newline:
                        (assign output (concat (value output) "
")) ;
                        for i in (range 0 (len pattern)) -{
                            # For each rule:
                            ...[ ,lhs, ,rhs, >>
                                let j = (new_cell 0) ;
                                    all_match = (new_cell true) ; in -{
                                # For each cell in the rule:
                                -{
                                    ...[ ,lhs, ,rhs, >> -{
                                        let mod_ij = (modulo (plus i (value j)) (len pattern)) ; in
                                        let **[matches ignored]** =
                                            (,[lhs], (value (index pattern mod_ij))) ; in
                                            (if matches
                                                **[]**  # do nothing
                                                (assign all_match false)) ;
                                        (assign j (plus (value j) 1))
                                    }- ]... ;
                                    **[]**
                                }- ;
                                (assign j 0) ;
                                (if (value all_match) -{
                                    # For each cell in the rule (again, to write results):
                                    ...[ ,lhs, ,rhs, >> -{
                                        let mod_ij = (modulo (plus i (value j)) (len pattern)) ; in
                                        let **[ignored output]**
                                                = (,[rhs], (value (index pattern_buffer mod_ij))) ; in
                                            (assign (index pattern_buffer mod_ij) output) ;
                                        (assign j (plus (value j) 1))
                                    }- ]... ; **[]** }-
                                    **[]**  # else, do nothing
                                )
                            }- ]...
                            ;
                            **[]**
                        }- ;

                        # Flip the buffer:
                        for i in (range 0 (len pattern)) -{
                            (assign (index pattern i) (value (index pattern_buffer i)))
                        }-


                    }- ;
                    (value output)
                }-
            ]'
        }.
    forall . '{[
        lit ,{DefaultWord}, = 'No'
        body := ( ,{Expr< [Bool -> **[Bool Bool]** ] >}, )
    ]}' negate -> .{
        '[Expr |
            .[ cell : Bool .
                let **[matches output]** = (,[body], cell) ; in
                # pattern: negate / output: negate
                **[ (not matches) (not output) ]**
            ].
        ]'
    }.
    forall . '{[
        lit ,{DefaultWord}, = 'cell'
    ]}' atom_match -> .{
        '[Expr |
            .[ cell : Bool .
                # pattern: match if present / output: set to true
                **[ cell  true ]** ].
        ]'
    }.
    forall . '{[
        lit ,{DefaultToken}, = '_'
    ]}' wildcard -> .{
        '[Expr |
            .[ cell : Bool .
                # pattern: always match / output: no effect
                **[ true  cell ]** ].
        ]'
    }.
    ]alt ;
in
Atoms
  cell '#'
Rules
  [ _ | _ | _ ] -> [ _ | cell | _ ]                 # By default, cells are on...
  [ _ | No cell | No cell ] -> [ _ | No cell | _ ]  # Unless they and their rightwards neighbor are off...
  [ cell | cell | cell ] -> [ _ | No cell | _ ]     # Or they and both neighbors are on.
Start
  # The "default wallpaper", with a glider moving to the right:
  [   #  ## #####   ### ###   #  ## #####   #  ## #####   #  ## #####]