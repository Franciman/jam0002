import /[build_a_language.unseemly]/
extend_syntax
    # Reserve some words:
    DefaultAtom ::= common ( ,{DefaultWord}, reserving 'Atoms' 'Rules' 'Start' 'No' ) ;

    # Reserve some symbols:
    DefaultToken ::= /\s*(\[|\]|\||->|capture_language)/ ;

    Expr ::= alt[
        # `ActuallyBool` is a hack; we need type variable inside each `*`
        forall ActuallyBool . '{[
            lit ,{DefaultWord}, = 'Atoms'
            # [
                atom_name := ( ,{Pat<Bool>}, )
                ,{DefaultSeparator},
                spelling := ( /'(.)'/ )  # any single character in quotes
            # ] *
            lit ,{DefaultWord}, = 'Rules'
            [
                lit ,{DefaultToken}, = '['
                lhs := ( ,{Expr< [ActuallyBool -> **[Bool Bool]** ] >}, ) # <-- atom_name : Bool
                lit ,{DefaultToken}, = ']'
                lit ,{DefaultToken}, = '->'
                lit ,{DefaultToken}, = '['
                rhs := ( ,{Expr< [ActuallyBool -> **[Bool Bool]** ] >}, )
                lit ,{DefaultToken}, = ']'
            ] *
            lit ,{DefaultWord}, = 'Start'
            ,{DefaultSeparator},
            start_pattern := ( /\[([^\]]*)\]/ )
        ]}' top_level -> .{
            '[Expr|
                let string_pattern = ,[(prefab (string_to_sequence (ident_to_string start_pattern)))], ; in
                    # Inconveniently, `cell` is also Unseemly's word for a mutable container.
                let pattern = (map string_pattern .[ char : Int . (new_cell (equal? char 35)) ].) ;
                    # Buffer all writes so that subsequent rules don't "see" each other's effects.
                    # (This is different than how PuzzleScript does it, but it allows cellular-automaton-like behavior)
                    pattern_buffer = (map string_pattern .[ char : Int . (new_cell (equal? char 35)) ].) ;
                    output = (new_cell "") ; in


                -{
                    for step in (range 0 10) -{
                        # output:
                        for entry in pattern
                            (assign output (concat (value output)
                                (if (value entry) "#" " "))) ;
                        # append a newline:
                        (assign output (concat (value output) "
")) ;

                        for i in (range 0 (len pattern)) -{
                            ...[ ,lhs, ,rhs, >>
                            let **[matches ignored]** = (,[lhs], (value (index pattern i))) ; in
                                (if matches
                                    let **[ignore output]** = (,[rhs], (value (index pattern i))) ; in
                                        (assign (index pattern_buffer i) output)
                                    **[]**)
                            ]...
                            ; **[]**
                        }- ;

                        # Flip the buffer:
                        for i in (range 0 (len pattern)) -{
                            (assign (index pattern i) (value (index pattern_buffer i)))
                        }-


                    }- ;
                    (value output)
                }-
            ]'
        }.
    forall . '{[
        lit ,{DefaultWord}, = 'No'
        body := ( ,{Expr< [Bool -> **[Bool Bool]** ] >}, )
    ]}' negate -> .{
        '[Expr |
            .[ cell : Bool .
                let **[matches output]** = (,[body], cell) ; in
                # pattern: negate / output: negate
                **[ (not matches) (not output) ]**
            ].
        ]'
    }.
    forall . '{[
        lit ,{DefaultWord}, = 'cell'
    ]}' atom_match -> .{
        '[Expr |
            .[ cell : Bool .
                # pattern: match if present / output: set to true
                **[ cell  true ]** ].
        ]'
    }.
    ]alt ;
in
Atoms
  cell '#'
Rules
  [ cell ] -> [ No cell ]
  [ No cell ] -> [ cell ]
  # [ | | ] -> [ | cell | ]                    # By default, cells are on...
  # [ | No cell | No cell ] -> [ | No cell | ] # Unless they and their rightwards neighbor are off...
  # [ cell | cell | cell ] -> [ | No cell | ]  # Or they and both neighbors are on.
Start
  # The "default wallpaper", with a glider moving to the right:
  [   #  ## #####   ### ###   #  ## #####   #  ## #####   #  ## #####]