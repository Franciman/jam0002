# Programming
Programming consists of, broadly, 2 things:
1. Breathe in (grok)
2. Breathe out (format information).

In between 1 & 2 there is the issue of storing information and querying information.

# Grokking Information - Pattern Matching

# Storing Information
## Storing Information - Normalization
What if you could store information in a language agnostic manner?  

Ideally, we use pattern matching to grok the information, then we write it out in some standard format.

You want to "normalize" the information, so that it was always stored in the same format regardless of where it came from.

Say, JSON.

## Querying Information - Pattern Matching (Again)

What if you could query information in a language agnostic manner?

# Formatting Information

# What Is Information?
## Project-Specific Information
## Programming Information

# Related
## Projectional Editing
The goal of projectional editing is 
1. To grok programs - in various languages
2. To query, and modify, the programs.

Essentially, we want to store a program in some database, then edit the program by editing the database.

## Software Architecture
We want to understand a program.

Lisp macros.

## Programming Languages Are Patterns
Patterns for controlling machines (computers).

We can control a machine by toggling it using a bank of switches.

We can convert the bank of switches into something more convenient, e.g. a bank of characters that are converted into switching control (of the computer).

When we do this recursively, we end up with progamming languages.

Programs written in high-level programming languages are converted to lower-level banks of characters which are then converted into switching control (e.g. C++ to ASM to binary codes for controlling computers).

All languages that produce code for a particular CPU, funnel down to the same binary codes (regardless of which programming language they were written in originally).

The goal of projectional editing is to find a way to *normalize* all programs into a common form that can be easily edited (queried - editing starts with querying).

## FP (Functional Programming)

FP - eg. Haskell - uses pattern matching.

Parsing is more powerful than FP pattern matching.

[[Pattern Matching]]
[[Normalization]]